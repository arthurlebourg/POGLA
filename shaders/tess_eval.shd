#version 450

// put the layout for lines
layout(patches, equal_spacing, ccw) in;

in VS_OUT {
    vec3 position;
    vec3 normal;
    vec2 uv;
} tcs_out[];

out TCE_OUT {
    vec3 position;
    vec3 normal;
    vec2 uv;
    vec3 color;
    vec4 p1;
    vec4 p2;
    vec4 p3;
    vec4 p4;
    int display;
} tce_out;

uniform mat4 model_view_matrix;
uniform mat4 projection_matrix;

void main()
{
    vec3 normal1 = normalize(tcs_out[0].normal + tcs_out[1].normal + tcs_out[2].normal);
    vec3 normal2 = normalize(tcs_out[1].normal + tcs_out[2].normal + tcs_out[3].normal);

    vec3 center1 = (gl_in[0].gl_Position.xyz + gl_in[1].gl_Position.xyz + gl_in[2].gl_Position.xyz) / 3.0;
    vec3 center2 = (gl_in[1].gl_Position.xyz + gl_in[2].gl_Position.xyz + gl_in[3].gl_Position.xyz) / 3.0;
    
    vec3 cam_pos = vec3(inverse(model_view_matrix) * vec4(0.0, 0.0, 0.0, 1.0));

    float dot1 = dot(normal1, normalize(cam_pos - center1));
    float dot2 = dot(normal2, normalize(cam_pos - center2));

    tce_out.p1 = gl_in[0].gl_Position;
    tce_out.p2 = gl_in[1].gl_Position;
    tce_out.p3 = gl_in[2].gl_Position;
    tce_out.p4 = gl_in[3].gl_Position;
    // check if dot1 and dot2 have the same sign
    if (dot1 * dot2 > 0.0) {
        // if so, discard the triangle
        tce_out.color = vec3(1.0, 0.0, 0.0);
        tce_out.display = 1;    
    }
    else
    {
        // if not, draw the triangle
        tce_out.color = vec3(0.0, 0.0, 1.0);
        tce_out.display = 1;
    }

    vec3 p1 = mix(tcs_out[0].position, tcs_out[1].position, gl_TessCoord.x);
    vec3 p2 = mix(tcs_out[2].position, tcs_out[3].position, gl_TessCoord.x);
    vec3 p = mix(p1, p2, gl_TessCoord.y);
    tce_out.position = p;
    
    vec3 n1 = mix(tcs_out[0].normal, tcs_out[1].normal, gl_TessCoord.x);
    vec3 n2 = mix(tcs_out[2].normal, tcs_out[3].normal, gl_TessCoord.x);
    vec3 n = mix(n1, n2, gl_TessCoord.y);
    tce_out.normal = n;

    vec2 uv1 = mix(tcs_out[0].uv, tcs_out[1].uv, gl_TessCoord.x);
    vec2 uv2 = mix(tcs_out[2].uv, tcs_out[3].uv, gl_TessCoord.x);
    vec2 uv = mix(uv1, uv2, gl_TessCoord.y);
    tce_out.uv = uv;
}